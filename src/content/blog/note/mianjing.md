---
title: 秋招面经
link: mianjing
catalog: true
date: 2024-01-01 00:00:00
description: 记录了一些本人于 2025.02 ~ 2025.10 实习面试和秋招面试期间 学习和经历的面试经验，主要为八股
tags:
  - 入门
  - 游戏开发
categories:
  - 笔记
sticky: false
---



<This File Is Encoded By UTF-8>

## 面试问题总结

#### C++各版本新增内容

###### C++11

- `auto`：编译期自动推导变量类型
- `decltype`：用于推导表达式类型
- 右值引用
- 移动语义
- 完美转发
- 返回值优化
- 初始化列表
- `std::function`
- `std::bind`
- `lambda`表达式
  - 定义简单的匿名函数`[外部捕获参数](参数)->返回值 {函数体}`
  - 捕获外部变量``
  - 作为函数参数
  - 作为函数返回值
- 并发相关
- 智能指针有什么类型,各自的原理
  auto_ptr：独占式拥有,同一时间只能有一个智能指针可以指向该对象。但在 C++11 被抛弃,因为在函数传参时对象所有权不会返还,造成内存泄露问题,不能指向数组也不能作为容器的成员。
  unique_ptr：独占式拥有,无法进行拷贝构造和赋值,但可以进行移动构造和赋值。
  shared_ptr：共享式拥有,多个指针可以指向相同的对象,该对象及其相关资源会在其所指对下那个不再使用后自动释放与对象相关的资源。
  weak_ptr：解决了 shared_ptr 互相引用时的死锁问题,不会增加到对象的引用计数。
- 基于范围的 for 循环：`for(auto& i : variable)`
- 委托构造函数
- 继承构造函数`using Base::Base`
- `nullptr`
- `final` & `override`
- 默认构造函数 `= default`
- 禁止某函数使用 `= delete`
- `explicit`：专用于修饰构造函数,表示智能显式构造,不能隐式转换
- `constexpr`：修饰的函数在编译期间就可以被计算出来,修饰的常量整个运行过程中都不能被更改。
- `if constexpr`配合类型萃取
- 自定义字面量
- 内存对齐
  变量在内存中的地址必须满足特定的对齐要求。可以让 CPU 减少内存访问次数,提高缓存命中率。由于 ARM 在没有对齐时可能会抛出硬件异常,因此手动保证对齐可以提高跨平台兼容性。\
  默认会根据成员变量的类型和结构体的最大类型进行对齐,可以手动通过`#pragma pack(n)`指定对齐的字节(实际对齐字节数为自身要求的字节数与n之间的最小值)。\
  内存对齐会增加填充字节,导致内存浪费,但可以提高缓存友好性,提高 CPU 的访问效率和批量处理能力。
- 随机数`random`
- 时间库`chrono`
- 新增算法
  - `any_of/all_of/none_of`
  - `find_if/find_if_not`
  - `copy_if`
  - `transform`
  - `is_sorted`
  - `iota`

###### C++14

- 函数返回值类型自动推导,虚函数无法使用
- lambda 表达式可以用 auto 进行声明,可以对参数赋初值
- 变量模板：

      template <class T>
      constexpr T pi = T(3.14159L)

- 别名模板
- `[[deprecated]]`标记,代表修饰的内容可能会被丢弃
- 二进制字面量和分隔符`0b0001'1100'10101`
- `std::shared_timed_mutex`&`std::shared_lock`读写锁
- `std::integer_sequence`
- `std::exchange`只会对旧值赋值,不是交换值
- `std::quoted`用于给字符串添加双引号
- `std::make_unique<T>()`

###### C++17

- 构造函数模板推导
- 结构化绑定,例如`auto[i,d] = std::tuple<T1,T2>()`,可以配合引用用于改变值。
- if-switch 语句初始化

      int a = 1;
      if(a < 100)
        stm;//相当于
      if(int a = 1; a < 100)
        stm;

- `inline`内联变量,可以直接在结构体内或者头文件内初始化静态成员变量
- 折叠表达式：常用于需要对参数包中的所有元素执行统一操作的场景。

  template<typename... Args>
  auto sum(Args... args) {
  return (... + args);
  }//累加
  template<typename... Args>
  string concatenate(Args&&... args) {
  return (string{} + ... + forward<Args>(args));
  }// 字符串拼接

- 可以使用 constexpr lambda 表达式
- namespace 嵌套：`namespace A::B::C{}`
- `__has_include`预处理表达式,用于判断是否已经包含有某个头文件
- 新增 Attribute
  - `[[noreturn]]`无返回值
  - `[[nodiscard]]`返回值不可被忽略
  - `[[maybe_unused]]`提示编译器修饰的内容可能暂时没有使用
- `std::variant`支持复杂类型的 union
- `std::monostate`：用于`std::variant`的空选项,用于默认构造
- `std::optional`允许使用空值`std::nullopt`
- `std::any`
- `std::apply`
- `std::make_from_tuple`将 tuple 展开为构造函数参数

      auto tuple = std::make_tuple(a,b,c);
      std::make_from_tuple<T>(std::move(tuple));
      //这里将tuple展开作为T的构造函数参数

- `std::string_view`
  对字符串不具有所有权,包含`std::string`的所有只读接口
- `std::as_const`
- `std::file_system`
- `std::shared_mutex`
- `SFINAE`Substitution failure is not an error\
  模板函数匹配中,当遇到匹配失败时不报错,所有匹配完且没有匹配的函数时才报错

#### C++相关

- C 与 C++的区别
  面向对象、RTTI
- 循环引用
  两个或者多个对象相互持有对方的引用,导致资源无法释放,常见于`shared_ptr`的使用中。
- 智能指针的构造与析构时间
  在使用`std:XXX_ptr`时会进行指针构造和内存分配,`weak_ptr`从`shared_ptr`构造。\
  `unique`在离开作用域时自动释放内存,`shared`在最后一个离开作用域时自动释放。`weak`不影响引用计数&,内存释放由`shared`决定
- 悬挂指针和野指针的区别
  悬挂指针：指针指向的对象被释放,但指针指向内存不变。
  野指针：未初始化的指针。
- 内存如何分区,分别存放什么
  全局区：存放全局变量和静态变量
  代码区：存放程序的二进制代码
  堆区：存放动态分配的内存
  栈区：存放自动管理的局部变量、函数参数等
- 划分堆栈有什么意义：为了高效灵活地管理内存，可以适应不同的需求；栈区主要由系统、CPU 寄存器管理，分配和回收速度快，适合小和生命周期短的临时变量存储；堆区需要手动申请和释放，适合较大的需要动态分配的数据。
- const 的原理
  对于在定义时就被赋值的变量，编译器会在编译阶段就将其视为常量，并将值直接嵌入代码中。
- static 和 const 变量初始化的时间
  - static 变量会在进入作用域时初始化
  - const 全局变量则会在编译时初始化；如果局部变量则在运行时初始化，存放在栈区。
- 什么 const 在常量区,什么 const 在栈区,什么 const 放入符号表优化
  当 const 常量在程序的整个生命周期内都有效且不会改变；当 const 变量为局部变量时；当 const 变量没有被修改时,会将其内联到代码中
- 虚函数表放在什么地方,为什么
  存储在全局数据区,因为它和类绑定,对象需要通过虚函数表进行动态绑定
- 多态的定义、种类和实现
  定义：一个类实例的相同方法在不同情形下有不同的表现形式。
  静态多态：通过重载和模板技术实现,在编译期间确定。
  动态多态：通过虚函数和继承关系实现的,执行动态绑定,在运行期间确定。
- C++如何管理虚函数
  当编译器发现类中有虚函数时,会创建一张虚函数表(一个静态数组,存储了该类所有虚函数的地址),把虚函数的函数入口地址放在虚函数表中,并且在对象中增加一个指针 vptr(对象的内存起始位置通常是 vptr),用于指向类的虚函数表。当派生类覆盖基类的虚函数时,会将虚函数表中对应的指针进行替换,从而调用派生类中覆盖后的虚函数,从而实现动态绑定。当出现多继承时,子类会包含多个 vptr。
- 虚表初始化的时间：在编译时就已经决定了会创建怎么样的虚表；在程序启动时或在类的对象首次创建时初始化。
- 虚表指针什么时候产生
  在构造函数中进行初始化，虚表存放在全局区
- 虚函数表如何生成,是和类还是和对象绑定
  和类绑定的,同一个类的所有对象共享一张虚函数表。
- 纯虚函数`virtual rettype func() = 0`
- 构造函数、析构函数、普通函数里可以调用其它虚函数吗：可以
- `inline`可以修饰虚函数吗：可以
- 重载重写和覆写的区别
  重载(Overloading)：在同一作用域中,函数名相同但参数列表不同,编译时多态。\
  重写(Overriding)：基类与派生类之间,必须是虚函数,函数名、参数列表、返回类型完全相同,运行时多态。\
  覆写(Hiding)：基类和派生类之间,函数名相同,参数列表可以相同或不同。\
- 子类重写了虚函数会对虚函数表产生什么影响
  会用重写的函数地址覆盖原本虚函数表中父类函数的地址。
- 多继承的实现以及可能出现的问题
  菱形继承
- 内联是什么,递归函数的内联会有什么问题
  将函数调用直接替换为函数体的代码,而不是同光传动的栈的函数调用机制,可以提高程序性能,尤其是当函数非常简单且调用平凡时。内联只影响编译阶段,递归函数无法在编译时进行内联展开。
- 指针和引用的区别
  指针占用内存空间,引用不占用,只是给变量取了别名。引用不能更改绑定的变量。
- 怎么让对象只能创建在栈/堆/内存池中
  - 只能在堆：将构造函数声明为`private`,然后只允许使用工厂创建此对象
  - 只能在栈：将`new`&拷贝构造函数删除
- 如何重载 operator new(delete 同理)

      void* operator new(size_t size) {
        void* ptr = std::malloc(size);
        if(!ptr)
          throw std::bad_alloc();
        return ptr;
      }//重载全局new操作符

      class MyClass {
        public :
          static void* operator new(size_t size) {
            ...
          }//重载特定类的new
      };
      // 重载带参数的new
      void* operator new(size_t size,extra_args...);
      void* ptr= new(args...) constructor()l

- 类实例的内存存储形式是什么样子的
  - 对象的非静态成员变量
  - 虚函数表指针(如果存在虚函数)
  - 内存对齐和填充
- `final`标识函数不可被重写
  `override`表示重写父类函数
- 基类如果不使用虚析构函数会发生什么
  使用基类指针删除派生类对象时可能会导致未定义行为,导致派生类的资源未正确释放。
- 构造函数和析构函数能不能是虚函数,为什么？
  析构函数一般是虚函数,构造函数不能是虚函数,因为虚表指针需要在构造函数中构造。
- 如何计算类的大小
  - 对于普通类,成员变量大小 + 内存对齐填充 + vptr(如果有虚函数)
  - 对于单继承子类,基类大小 + 派生类新增成员大小 + 内存填充
  - 对于菱形继承子类,所有基类成员重复存储,总大小 = 各基类大小之和 + 派生类成员
  - 对于虚继承,每个虚继承路径添加`vbptr`,虚基类成员仅存储一份,总大小 = 非虚部分 + 虚基类部分
- 在构造虚函数时能够调用虚函数吗，析构函数中可以吗：可以
- `inline` 与宏区别
  `inline` 不能用于递归函数,宏不会进行作用域和类型检查；宏在预处理阶段进行文本替换,`inline`会由编译器决定是否展开。
- 类中静态变量的初始化是什么时候
  在第一次访问该类的实例时,或者加载库时
- 引用折叠`Reference Collapsing`
  引用折叠描述了当多个引用组合时如何折叠成最终的引用类型,主要出现在模板参数推导和`typedef`中,遵循‘左值引用优先’的规则。这一机制广泛运用于完美转发、避免拷贝和移动不必要的对象。
- `volatile`关键字：防止编译器优化
- `new` 和 `malloc` 的差别
- 无效引用：引用的对象已经被销毁或使用
- 各种 stl 容器底层的数据结构

  |             容器              | 数据结构 |
  | :---------------------------: | :------: |
  |           `vector`            | 动态数组 |
  |            `list`             | 双向链表 |
  |            `stack`            |  适配器  |
  |        `set/multiset`         |  红黑树  |
  |        `map/multimap`         |  红黑树  |
  | `unordered_set/unordered_map` |  哈希表  |
  |       `priority_queue`        |  最大堆  |

- RTTI 原理,type_info 信息存储在虚函数表的哪里
  `type_info`指针一般为虚函数表的第一项,存储类型名等信息,能在运行时获取对象的实际类型。
- C++的空类包含哪些成员函数
  默认构造函数、默认拷贝构造函数、默认析构函数、赋值运算符重载、取址运算符重载,取址运算符 const(后两者只有在实际使用时编译器才会定义)
- 四种 cast 类型转换简述(这四个是内建运算符不是 stl)
  const_cast：将 const 变量转为非 const
  static_cast：用于各种隐式转换,如非 const 转 const,void\*转指针等,向上转换安全,反之不安全。
  dynamic_cast：用于动态类型转换,只能用于含有虚函数的类。
  reinterpret_cast：都可以转,但可能出问题。
- C++哪些情况下会产生临时对象
  - 当函数返回值是非引用类型时
  - 当对象值传递给函数作为参数时
  - 隐式类型转换时
  - 运算符重载时,如果返回的是一个对象
  - 使用`decltype(auto)`时
  - 可以将临时对象绑定到`const auto&`以延长临时对象的生命周期。
- 转发和完美转发的概念
  转发指的是向另一个函数传递参数。
  完美转发是一种模板技术,允许函数在不丢失参数的左值/右值属性的情况下把参数传递给另一个函数。通常使用`T&&`(万能引用)+`std::forward<T>`实现,可以避免不必要的拷贝,提高效率。
- vector 的 capacity 和扩容机制,使用时要注意什么
  避免频繁扩容,避免存放大对象
- 如果扩容时会引发自定义类型挨个复制构造,C++有什么机制来避免这一点
  可以在 vector 中存放指针作为替代,使用移动语义避免不必呀的赋值构造。
- C++ lib 和 dll 的区别\
  lib：静态链接,在编译时直接将需要的执行代码拷贝到调用处；优点是程序发布时不需要依赖库可以独立运行；缺点是程序体积增大,且静态库更新之后所有可执行文件需要重新链接。\
  dll：动态链接,在编译时记录一系列符号和参数,在程序运行或加载时将这些信息传递给操作系统,由操作系统加载动态库,然后在程序运行到特定代码时直接执行已经加载的动态库代码,实现运行时链接。优点是节省资源,但由于运行时加载,可能影响程序的前期执行性能。
- 顺序遍历链表和顺序遍历数组哪个更快,数组更快
  1. 内存访问局部性
  2. 在遍历链表时需要进行指针解引用,而数组只需要计算偏移量
  3. 数组的内存空间一次性分配并且大小固定,可以直接计算元素地址,指令优化级别较高,链表的存储的内存比较碎片化。
- `memory_move` 和 `memory_copy` 的作用和区别
  - 它们的作用都是从一块内存拷贝数据到另一块内存
  - `memory_move`支持重叠的内存区域,较安全但是更慢
  - `memory_copy`不支持重叠的内存区域,但是较快
- C++有什么功能和面向对象的三大特性违背
  友元`friend`破坏了类的封装性\
  指针和强制类型转换\
  多继承\
- 一段代码怎么样在 main 函数之前调用
  全局对象的构造函数\
  全局函数的调用\
  使用`__attribute__((constructor))`标记为在 main 函数前执行
- 可变参数：使用`<cstdarg>`

  #include <cstdarg>
  int sum(int count, ...) {
  va_list args;
  va_start(args,count);
  process();// 处理参数
  va_end(args);
  }

- 可变参数模板：使用递归展开或者折叠表达式(C++17)

      void print() {cout << endl;}

      template <typename T,typename... Args>
      void print(T first Args rest) {
        cout << first << " ";
        print(rest...);
      }// 每次递归时去掉第一个参数,传递剩余参数

      template <typename... Args>
      void print(Args... args) {
        (std::cout << ... << args) << std::endl;
      } // 使用折叠表达式

- 模板是要解决什么问题,有什么缺点
  - 提高开发效率,代码复用率和类型安全性
  - 缺点有编译时间长、代码膨胀；并且模板错误信息复杂,难以 Debug。
- 模板特化、偏特化
- `unordered_map`内部怎么取 hash 值和处理哈希冲突
  - 通过`std::hash`模板类将键值映射到哈希表中,这个模板类专门用于对内置类型进行哈希计算,对于自定义类型,需要提供自定义的哈希函数。
  - `std::unordered_map`使用链地址法处理哈希冲突,哈希表中每个桶通常是一个链表,用于存储多个哈希值相同的元素。
  - 当负载因子超过阈值时会自动扩展桶并 rehash
- 智能指针的内部实现,如何管理里面的指针的
  - unique：不支持拷贝构造和移动构造；但支持移动构造和移动赋值
  - shared：维护一个计数器，用于记录当前有多少个 shared_ptr 持有该对象
  - weak：同时维护一个 shared_ptr 的引用数量用于判断对象是否可用
- 进程是系统分配资源的最小单位，线程是处理调度的最小单位，（一个线程有几个栈？）线程有独立的调用栈
- 什么是无锁队列
- 多线程的通信方式
  - 共享内存 + 同步机制
  - 消息队列
  - 条件变量
- 多进程的通信方式
  - 管道
  - 消息队列
  - 共享内存
  - socket
  - 文件映射
  - rpc
- 容器迭代器的原理
- vector 怎么释放空间
- C++的异常处理机制
  - 基于三个关键字`throw`,`try`,`catch`
  - 基于栈展开和运行时类型信息
    - 栈展开：从当前作用域开始向上查找catch块，查找过程中所有离开作用域的析构函数都会被调用
    - rtti：匹配catch语句中的异常类型
  - 基于异常表：编译时生成一个异常表，存储try-catch块和异常类型的信息，当异常被抛出时，通过查表进行匹配。
  - 在性能敏感的代码和构造函数中不应该使用异常。
- 优先级队列的时间复杂度和空间复杂度
  - 通常使用最大堆或者最小堆实现
  - 空间复杂度为O(n)
  - 构建堆的时间复杂度是O(n)，插入删除为O(logn)，获取最大值为O(1)，清空为O(1)

#### C#相关

- 什么是垃圾回收及其工作原理
  自动内存管理机制,主要目的是识别并清除不再被应用程序使用的对象,从而释放可用的内存资源
  1. 内存分配,创建对象时`CLR(公共语言运行时)`会从托管堆宏分配内存,通常通过`new`关键字进行
  2. 标记阶段,GC 会定期运行,标记所有从根(全局变量、当前线程)可达的对象,所有可以通过这些根对象访问的对象以外的对象被视为垃圾。
  3. 清除阶段,标记完后遍历内存,清除并回收垃圾对象
  4. 压缩阶段,有时 GC 会进行压缩,以避免内存碎片\
     优势是自动管理内存和提高开发效率,但会提高运行时开销
- C#中的多线程如何实现
  1. 使用`Thread`类
  2. 使用`ThreadPool`
  3. 使用`Task`
  4. 使用`async/await`
- `NuGet`包管理工具
- 值类型与引用类型
  - `ValueType`直接存储数据值,默认值是其类型的零值,通常在栈上分配内存
  - `ReferenceType`存储的是真正数据的地址,默认值为`null`
- `string`与`StringBuilder``的区别和性能比较
  - `string`不可变,线程安全；`StringBuilder`可变
  - 在频繁修改字符串的场景,`StringBuilder`的性能比较好
- 动态类型`dynamic`和`var`的区别
  - var 相当于 auto,在编译时确定类型
  - dynamic 是动态类型,通常用于和动态语言交互,可能导致运行时异常
- 如何处理 JSON 数据
  通常使用内置的`System.Text.Json`或者`Newtonsoft.Json`库
- `Interface` 和抽象类之间的不同
- 关键字`Sealed`：防止修饰的类被继承
- `.NET`和`Mono`的关系
  - Mono 是一个开源项目,旨在使 .NET 应用程序能够在不同的平台上运行。它通过实现公共语言基础设施(CLI)标准,使得开发者可以用 C# 高级语言编写的程序在 Windows、Linux、FreeBSD 等平台上运行。
- C#中有哪些常用的容器
  `List<T>`、`Dictionary<TKey,TValue>`、`Queue<T>`、`Stack<T>`、`HashSet<T>`
- 委托和事件
  - 委托是一种类型安全的函数指针,可以指向任何符合签名的方法。使用类似于`std::function`
  - 事件是特殊的委托,用于实现发布-订阅模式,只能在声明类中触发
- `ref`关键字和`out`关键字有什么区别：都是引用传递参数的机制

  |         ref          |         out          |
  | :------------------: | :------------------: |
  |    必须初始化参数    |      无需初始化      |
  | 方法内可以读取和修改 | 方法内必须为参数赋值 |
  |     双向传递数据     |    需要返回多个值    |
  |     性能基本相同     |

- `unsafe`关键字
  `unsafe`允许函数中使用指针,会绕过 C#的内存管理和类型安全检查。
- 能用 foreach 遍历访问的对象需要实现`IEnumerable`接口或声明`GetEnumerator`方法
- 装箱：将值类型转换为引用类型`object`,并在堆上分配内存并储存该值
- 拆箱：将装箱后的对象转换回原始的值类型。装拆箱操作军会带来性能开销。
- Interface 和纯虚类的区别
  C#类可以继承多个 interface 但不能继承多个类；C#抽象类内的接口可以有默认实现，但接口不可以。

#### 数据结构与算法

- 二维平面内的多个矩形,如何根据重叠情况分组
- 数据流实时取中位数
  - 利用二分思想,维护一个大根堆和小根堆,让两个堆的大小差距不超过 1,取中位数只需要把大根堆和小根堆取平均。
- 3 或者 4 个数得到 24 点的算法
  - 穷举法
- 牛顿法求平方根
  $$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} $$
- 红黑树和 AVL 的区别
- O(1)哈希值如何实现
- 各排序算法及其复杂度
- 快速幂：分治
- 快速矩阵乘法
- 约瑟夫环
  - 方法一：使用循环链表模拟
  - 方法二：公式法；设当总人数为 N,杀掉第 M 个人时,胜利者为 $ f(N,M) $,有 $ f(N,M) = (f(N - 1,M) + M) \% N $
- dijkstra
- A\*：启发式寻路,通过维护当前位置和可达路径计算前进代价和离终点的代价选择下一步。
- 立方体碰撞检测 分离轴定理`SAT`：如果两个凸体没有发生碰撞,则存在一个平面能使得两个立方体被分开
  - 计算立方体的面法向量
  - 计算立方体棱向量
  - 计算分离轴：通过两立方体的边缘方向叉积和面法向量可以生成可能的分离轴,总计有 15 条可能的轴(两个立方体各三个面的法向量 & 各三条边缘方向的组合叉积)
  - 投影顶点到分离轴：通过将两个立方体所有顶点投影到分离轴上,并比较投影的最值,若有任意一堆轴上投影补充和,说明两立方体没有碰撞。
- 红黑树的设计目的、解决了什么问题
  - 设计目的：保证了所有基本操作都能在最坏复杂度为对数复杂度内完成，在保持良好平衡性的同时避免了 AVL 需要频繁旋转的操作。红黑树没有高度差限制，它的最坏情况的高度为`2 * log(n)`
  - 红黑树相比 AVL 数在插入和删除时性能较优，在查找时较低效
- 有一个 500 万人的战力榜,取前 100 或 200,设计一个算法做高效的增删改查?
- 如果 A\*算法得到锯齿状的路径,如何优化或平滑
  1. 直线连接，对于路径上的两个点间如果可以直接到达，则直接使用直线连接
  2. 使用贝塞尔、样条曲线等方法拟合
  3. 使用让 A\*算法允许使用对角线搜索，或在代价函数中添加权重，使算法更倾向于选择更直线的路径。
- 链表的倒数第 k 个节点：双指针，前面的先走 k 步，后面的就是答案。
- 快速排序、快速排序基准数优化
- 洗牌算法
- 球谐函数
- 双调排序

#### 设计模式

- 开闭原则：对扩展开放,对修改关闭
- 单一职责原则：一个类只负责一个功能领域中的相应职责
- 里式代换原则：所有引用基类的对象必须能透明地使用其子类的对象
- 依赖倒转原则：依赖于抽象,不能依赖于具体实现
- 接口隔离原则：类之间的依赖关系应该建立在最小的接口上
- 合成/聚合复用原则：尽量使用合成/聚合而不是继承
- 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用
- 常用设计模式：
  - 单例模式
    - 缺点
      - 高耦合，模块间可能通过单例隐式耦合，修改单例会影响所有依赖于它的模块
      - 线程不安全，如果使用延迟初始化可能导致创建多个实例并导致内存泄露
      - 生命周期过长，会长期占用资源
      - 测试困难，在不同用例间共享状态，导致测试结果不可靠
  - 工厂方法模式：通过定义一个接口来创建对象,但让子类决定实例化哪个类，适合只需要生产一种产品的不同类型的情况
  - 抽象工厂模式：通过定义多个工厂方法来创建不同的产品，适用于需要生产一系列相关产品的场景
  - 观察者模式：定义了一种依赖关系,让多个观察者对象可以在被观察对象(即“主题”)状态变化时自动收到通知。让代码宣称某事件发生而不必关心谁接受了通知；例如成就系统。
  - 适配器模式：一个类的接口转换成客户端期望的另一种接口,适用于现有代码不兼容的情况。
  - 策略模式：允许在运行时选择算法的行为,可以定义一系列算法,并让它们可以互换。
  - 命令模式：将一个请求封装成一个对象对象，从而使你可用不同的请求对客户进行参数化；使用场景比如请求排队或者记录请求日志,命令序列化，支持可撤销的操作。

        // 例如：封装按键命令，支持更换按键绑定的命令
        class Command {
          public:
            virtual void execute() = 0;
        };
        class JumpCommand : public Command {
          public : 
            virtual void execute(GameObject& go) overrider {
              go.jump();
            }
        };
        Command* InputHandller::handleInput(){
          if(isPressed(BUTTON_X)) return buttonX_;
        }

  - 状态模式：行为型设计模式，允许对象在内部状态改变时改变其行为。它将状态逻辑封装到独立的状态类中，使得对象的行为和状态的变化解耦。可能会产生大量状态类。
  - 享元模式：结构型的设计模式，通过共享对象来减少对象的数量，通过缓存共享对象，降低内存消耗。
  - 原型模式：创建型设计模式通过克隆已有对象来创建新的对象，适用于需要大量创建相似对象的场景，通常与工厂模式结合使用。
- 序列模式
  - 双缓冲模式：用序列的操作模拟瞬间或者同时发生的事情；定义两个或多个缓冲区，在完成一个缓冲的所有指令时再交换缓冲。应用在几乎所有图形API中。
  - 游戏循环：将游戏的进行和玩家的输入解耦，和处理器速度解耦；让游戏可以不管潜在的硬件条件，以固定的速度运行游戏。
  - 更新方法：对每个对象实现一个更新方法，模拟对象在一帧内的行为
- 行为模式
  - 字节码：将行为编码为虚拟机器上的指令，赋予其数据的灵活性。例如MC的指令
  - 子类沙箱：用一系列由基类提供的操作定义子类中的行为；基类定义抽象的沙箱方法和几个提供的操作。 将操作标为protected，表明它们只为子类所使用。每个推导出的沙箱子类用提供的操作实现了沙箱函数。
  - 类型对象：创造一个类A来允许灵活地创造新“类型”，类A的每个实例都代表了不同的对象类型。
- 解耦模式
  - 组件模式：允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。将每部分代码放入各自的组件类中，实体被简化为组件的容器。
  - 事件队列：解耦发出消息或事件的时间和处理它的时间。事件队列在队列中按先入先出的顺序存储一系列通知或请求。发送通知时，将请求放入队列并返回。 处理请求的系统之后稍晚从队列中获取请求并处理。
  - 服务定位器：提供服务的全局接入点，避免使用者和实现服务的具体类耦合。服务 类定义了一堆操作的抽象接口。 具体的服务提供者实现这个接口。分离的服务定位器提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。
- 优化模式
  - 数据局部性：合理组织数据，充分利用CPU的缓存来加速内存读取。
  - 脏标识模式：将工作延期至需要其结果时才去执行，避免不必要的工作。
  - 对象池模式：放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率。
  - 空间分区：将对象根据它们的位置存储在数据结构中，来高效地定位对象。其实就是KD-Tree、BVH等空间划分算法。
- MVC
- MVP
- MVVM：`Model - View - ViewModel`
  - Model：负责管理数据和业务逻辑
  - View：用户界面部分，显示数据并响应用户的交互操作
  - ViewModel：作为中介，负责从Model获取数据并格式化后提供给View
  - 解耦用户界面和业务逻辑
  - 易于单元测试

|创建型|结构型|行为型|并发型|架构型|
|:-----:|:-----:|:-----:|:------:|:------:|
|单例模式|适配器模式|责任链模式|线程池|MVC|
|工厂方法模式|装饰器模式|命令模式|读写锁|MVVM|
|抽象工厂模式|享元模式|策略模式|反应器模式|微服务架构|
|建造者模式|代理模式|观察者模式|||
|原型模式|组合模式|状态模式|||

###### 多线程模式
1. 不可变对象模式 Immutable Object：通过将对象变为只读的形式保证线程安全
2. 保护性暂挂 Guarded suspension：当线程在执行时有一些需要的条件未满足，通过暂挂（空循环之类的）等待条件满足
3. 两阶段终止 two-phase termination：等待线程完全执行完后再终止
4. 承诺 promise：
5. 生产者-消费者 producer-consumer：生产者将产生的数据放入队列，消费者则从队列中拿数据；可以使用多个通道进行消费，减少锁竞争
6. 主动对象 active object：将方法的调用和执行解耦，使用者通过同步的方式调用，后台以异步的方式执行
7. 线程池 thread pool：减少开启和关闭线程带来的额外开销
8. 线程特有储存 thread specific storage：每个线程独立存储数据来避免竞争
9. 串行线程封闭 serial thread confinement：保证每次只有一个线程访问非线程安全对象
10. 主仆模式 master-slave：将任务拆解成小任务，然后交给不同的线程完成，最后将任务合并
11. 流水线 pipeline：将任务分解成不同阶段
12. 半同步/半异步 halfsync/halfasync：将模块分成中间层、同步层、异步层，同步层进行同步编写，异步层进行IO操作，操作完成后将数据放入中间层，而同步层从中间层取得数据

#### 图形学相关

- 矩阵 SVD 分解
- LU 分解
- 给定点集求凸包
  - `Graham Scan`算法(贪心,复杂度 O(nlogn))
    1. 选择一个最底部(最左)的点作为基准点
    2. 将其他的点按相对基准点的极角排序
    3. 用栈存储凸包的点,遍历排序后的点,将他们逐一加入栈中
    4. 对于新加入的点检查栈顶的两个点与当前点的方向
    5. 如果为“右转”则移除栈顶的点,如果为左转,则保留
  - `Monotone Chain`单调链算法,复杂度 O(nlogn)
- 向量点乘和叉乘的几何意义
  - 点乘反映两个向量的夹角关系
  - 叉乘在三维空间中反映两个向量构成的平面与法向量的关系\
    在二维空间中表示两个向量构成的平面四边形的面积。
- 判断多边形是否为凸多边形
- 叉乘求多边形面积: $ 设顶点坐标为(x_i,y_i),则有面积 $
  $$ Area = \frac{1}{2}| \sum_{i=1}^{n-1}(x_iy_{i+1} - y_ix_{i+1}) + x_ny_1 - y_nx_1 | $$
- 行列式为 0 的意义
- 点到空间三角形的最近距离
- 齐次坐标
- 如何优化射线与球体相交
- 法线矩阵
- Model 矩阵的叠加顺序
  平移 _ 旋转 _ 缩放
- 正交矩阵的定义和特点,变换矩阵中有哪些是正交矩阵\
  定义：正交矩阵的转置矩阵是它的逆矩阵,行列式的值为$\pm 1$\
  特点：保持向量的长度不变、向量之间的角度不变\
  反射、旋转、正交投影矩阵、坐标轴变换矩阵
- 如何理解特征值和特征向量
  一般来说,特征向量实在经过矩阵变换后只改变大小而不改变方向的向量,特征值表示该向量在变换中的伸缩因子。
- 旋转矩阵的特征值含义
  三个特征值分别是$1,cos\theta \pm isin\theta$,1 对应的特征向量对应于旋转的轴。另外两个对应旋转平面。
- 切变矩阵的特征
- 如何表示一个平面
- View 矩阵和投影透视矩阵的推导
- 光栅化的定义与作用
- 四元数的使用、插值
- 渲染管线中,图形渲染过程有哪些坐标空间,各空间中,那些是左手系,那些是右手系,为什么会有变化

  |        空间        |             坐标系             |
  | :----------------: | :----------------------------: |
  |      模型空间      |             右手系             |
  |      世界空间      |             右手系             |
  |     摄像机空间     | 右手系(OpenGL),左手系(DirectX) |
  | 标准化设备坐标空间 |             右手系             |
  |      屏幕空间      |             左手系             |

- 片元`fragment`和像素`pixel`的区别:片段数光栅化过程中的一个数据单位,包含了一个潜在像素的所有信息；像素时图像显示中的基本单位,表示最终的可视化结果。
- 什么时候在顶点做光照,什么时候在片元做光照
- 有哪些光照模型\
  `Lambertian Reflection`只包括漫反射\
  `Phong & Blinn-Phong`包括环境光、漫反射、镜面光\
  `PBR`基于物理的渲染\
  `AO`环境光遮蔽\
  `GI`全局光照\
  `Radiative Transfer Model`辐射传输模型\
- `MIPMAP` 原理、作用,如何确定使用哪一层
  - 通过相邻像素之间的UV坐标变化率，计算LOD值选择
- 法线贴图如何存储,为什么,有什么优缺点
  法线贴图存储在切线空间，这样法线始终相对于物体表面的局部坐标系，无论模型如何变换，法线贴图的方向都不会改变，并且可以复用，无需为每个物体单独烘培
- 什么是 gamma 矫正：使用 $ I_{out} = I_{in}^\gamma $对像素值进行调整。当 γ 小于 1 时用于增强暗部细节,反之则用于适应显示设备的非线性特性。
- 什么是 HDR`High Dynamic Range`高动态范围：动态范围指图像中最亮和最暗部分的亮度比值,通常通过合并不同光谱的图像来生成。
- 什么是色调映射`Tone Mapping`：将 HDR 图像转化为 SDR 图像的方法,常见的算法有线性缩放、对数映射等。
- shadowmap 实现、缺点、改进
  - 第一个 Pass：将摄像机放在光源位置,生成一张深度缓冲,并记录此时的投影变换矩阵 M
  - 第二个 pass：将相机放在光源位置,用矩阵 M 将渲染点变换得到深度$P_z$,与深度缓冲中进行对比,如果深度较大,则认为此片元处在阴影中。
  - 但是由于深度的精度和阴影贴图分辨率有限,所以需要在比较是添加偏差,当 bias 过小时,会出现`z-fighting`,过大时会出现`Peter Pan`
- `PCF,percentage-closer filtering`百分比近似滤波
- `PCSS,percentage0closer soft shadow`
- 有哪些抗锯齿方法
  - 基于超采样的
    - SSAA
    - MSAA：仅对几何边缘进行超采样
  - 基于屏幕空间的
    - FXAA：通过检测边缘颜色差异进行模糊
    - SMAA：FXAA的改进，使用模式匹配进行边缘检测
    - TAA：使用前后帧的像素信息，结合运动矢量进行抗锯齿
  - 基于深度学习的
    - DLSS
    - FSR
- 有哪几种缓冲,作用是什么
- 什么是模板测试,作用是什么
- computer shader
  一种不依赖于图形渲染管线的着色器,可以用于执行一般的计算任务
- compute shader 有什么应用
- 提高渲染效率的方法
- 辐射度量学
  - 辐射能`Radiant energy`:电磁辐射的能量 $ Q[J = Joule] $
  - 辐射通量`Radiant flux`：单位时间释放、反射、投射或者接受的能量
    $$ \Phi = \frac{dQ}{dt} [W = Watt][lm = lumen] $$
  - 辐射强度`Radiant Intensity`:单位立体角由点光源发出的功率
    $$ l(\omega) = \frac{d\Phi}{d\omega} [\frac{W}{sr}][\frac{lm}{sr} = cd = candela] $$
  - 立体角`Solid Angles`:球面上的投影面积与半径的平方之比 $\Omega = \frac{A}{r^2}$
  - 辐照度`Irradiance`:每单位面积入射到一个表面上一点的辐射通量
    $$ E(x) = \frac{d\Phi(x)}{dA} [\frac{W}{m^2}][\frac{lm}{m^2} = lux] $$
  - 辐射`Radiance`或者亮度`Luminance`：一个表面在每单位立体角、每单位投影面积上所发射的辐射通量。
    $$ L(p,\omega) = \frac{d^2\Phi(p,\omega)}{dwdAcos\theta} [\frac{W}{srm^2}][\frac{cd}{m^2} = \frac{lm}{srm^2} = nit]$$
- 什么是蒙特卡洛积分方法
- 介绍一下光线追踪和路径追踪
  - 光线追踪：根据几何光学规则，递归追踪光线路径来计算光照
  - 路径追踪，基于蒙特卡洛积分法，通过随机采样光线路径来模拟光的复杂传播
  - 重要性采样：根据光照分布，使用其他概率密度函数来代替原本的均匀采样
- 介绍一下渲染方程
  渲染方程的标准积分形式$$ L_o(x,\omega_o) = L_e(x,\omega_o) + \int_{\Omega} f_r(x,\omega_i,\omega_o) \cdot L_i(x,\omega_i) \cdot (n \cdot \omega_i)d\omega_i $$其中$L_o(x,\omega_o)$是视线方向$\omega_o$上的出射辐射亮度,决定了像素的颜色。
  $ L_e(x,\omega_o) $是该点在该方向上的发射光亮度(自发光)。\
  $ f_r(x,\omega_i,\omega_o)$ 双向反射分布函数,即 BRDF,描述表面如何反射入射光并在出射方向上散射,是一个反映材质属性的函数。\
  $ L_i(x,\omega_i) $是入射辐射亮度\
  $ (n \cdot \omega_i) $ 是法线与入射方向之间的点积,表示表面对入射光的接受程度
  $ \Omega $ 是单位半球所有可能入射方向
- 介绍一下 BRDF
- 常见的 BRDF 模型\
  `Cook-Torrance`:`lambertian`漫反射+高光\
  其中:
  1. $ D(h) $ 代表法线分布函数,用于估算在受到表面粗糙度的影响下,朝向方向与半程向量一致的微平面的数量。可以使用`Trowbridge-Reitz GGX`,其中 $\alpha$ 是粗糙程度
     $$ NDF\_{GGXTR}(n,h,\alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2(\alpha^2 - 1) + 1)^2} $$
  2. $ F(\omega_i,\omega_o) $ 代表菲涅尔方程,描述在不同的表面角下表面所反射的光线所占的比率。可以使用`Fresnel-Schlick`近似
  3. $ G(\omega*i,\omega_o) $ 代表集合函数,描述微平面自成阴影的属性；当一个平面相对粗糙时,表面上的微平面可能挡住其他微平面从而减少表面所反射的光线。可以使用`Smith's Schlick-GGX`,其中可以假设入射的阴影项和出射的遮蔽项函数形式相同。
     $$ G(i,o,n) = G_{sub}(i,n)\cdot G_{sub}(o,n) $$
    $$ G_{Schlick-GGX}(i,n) = \frac{i\cdot n}{(i\cdot n)(1 - k) + k} $$
  $$ f = f_d + f_r(\omega_i,\omega_o) = \frac{\rho_d}{\pi} + \frac{D(h)F(\omega_i,\omega_o)G(\omega_i,\omega_o)}{4(n\cdot \omega_i)(n\cdot \omega_o)} $$
  `Phong&BlinnPhong` $$ f_r(\omega_i,\omega_o) = \frac{k_s}{\pi}(h\cdot v)^n $$
  `Oren-Nayar` $$ f_r(\omega_i,\omega_o) = \frac{\rho_d}{\pi}(1 + A\cdot \max(0,cos\theta_i - cos\theta_o))$$
     `Ward` $$ f_r(\omega_i,\omega_o) = \frac{C}{\pi}exp(-\frac{(n\cdot h)^2}{\sigma^2}) $$
- 介绍一下 PBR 的原理
  基本原理是使光照计算符合实际物理规律,关键概念包括：能量守恒、微表面理论、镜面/漫反射、BRDF、菲涅尔效应。\
  必须满足三个条件：
  1. 基于微表面模型
  2. 能量守恒
  3. 应用基于物理的 BRDF
- PBR 的实现需要哪些参数
  反射率 Albedo、金属度 Metallic、粗糙度 Roughness、法线贴图 NormalMap、环境光遮蔽 AmbientOcclusion、镜面反射 Specular、发射光 Emissive、清漆层 ClearCoat。
  实现步骤：使用 Schlick 方法近似估算菲涅尔反射的反射系数,使用 Cook-Torrance BRDF 模型计算表面反射(结合粗糙度和金属度),计算漫反射和镜面反射,合成最终光照。
- 菲涅尔反射的 Schlick 近似
  $$ F(\theta) = F_0 + (1 - F_0) \cdot (1 - cos\theta)^5 $$
- 菲涅尔项的 F0 有什么含义
  含义为基础反射率,表示光线垂直入射时的反射 v,与材质的折射率相关
  $$ F_0 = (\frac{n_1 - n_2}{n_1 + n_2})^2 ,n_1 为入射介质的折射率,n_2 为材质折射率$$
- 如何保持稳定帧率
- 如何优化 shader 代码
- 了解过哪些 GPU 架构和图形 API
- DX 和 GL 的区别

  | DX                                | GL                       |
  | :-------------------------------- | :----------------------- |
  | 只要支持 Windows 和 Xbox          | 支持大多数平台           |
  | 高层抽象,集成音频、输入等多种功能 | 底层控制,专注于图形渲染  |
  | 由微软和硬件厂商共同支持          | 由各硬件厂商独立提供驱动 |

- GLFW 的作用
- 如果一个模型仅对 X 轴缩放,如何利用 M 矩阵计算光照
- 如果场景内多个同 mesh 物体,如何根据用户选择实时渲染其中的一部分
- 了解过哪些后处理方法
- 高斯模糊-bloom-NPR-卡渲
- 描边方法有哪些
- 对于一个设计好的效率较低渲染算法,如何最快分析 vs 和 fs 哪个对效率影响最大
- 前向渲染管线
  适用于光源较少、材质复杂、透明度处理要求高的场景,内存开销较低。对光源逐个进行光照计算,通常在一个渲染通道中完成所有渲染工作。
- 延迟渲染管线
  将所有物体的几何信息存储在 G-buffer 中,然后遍历所有光源并计算它们对每个像素的贡献。然后一次性计算所有光源。需要多个渲染通道和较大的内存带宽,但能够减少冗余光照的计算。
- 延迟渲染原理与实现
- 介绍一下 OpenGL 的渲染管线

  | 阶段           | 描述                    |
  | :------------- | :---------------------- |
  | 应用阶段       | 调用 API 为 GL 提供数据 |
  | 顶点处理阶段   | 使用 VS 变换顶点数据    |
  | 图元装配阶段   | 将顶点装配成图元        |
  | 裁剪阶段       | 剔除视口外的图元        |
  | 光栅化阶段     | 将图元转化成片段        |
  | 片段处理阶段   | 使用 FS 计算颜色        |
  | 深度与模板测试 | 进行深度和模板测试      |
  | 混合阶段       | 进行颜色混合            |

- 延迟渲染的优缺点
- 顶点光源和像素光源
- 纹理压缩算法
- 什么是 early-z
  早期深度测试,对于被遮挡的片段,直接丢弃不进行着色和混合,但不适合透明物体。
- 什么是 pre-z
- 环境光遮蔽`Ambient Occlusion`\
  模拟环境光在物体表面的散射和遮挡效应,模拟局部阴影效果,能够增强物体表面的细节感和深度感。
- 手推 点在三角形内、重心坐标计算、重心坐标插值、透视矫正、brdf 和 render-equation
- SSAO
- 线性空间和伽马空间
- 三维空间判断点在立方体内：AABB，先将立方体转到与坐标轴平行再用 AABB；通过计算点与平面的距离
- 直线绘制算法
  - DDA：根据两个点求出直线表达式，用每一步进差值大的那条轴做主方向
  - Bresenham
- 运动模糊
  - 计算运动矢量，进行模糊处理
  - 渲染多个帧，根据每个采样点的运动矢量进行加权平均
  - 后处理方法，渲染完成后模糊图像中的运动区域
- SDF的计算
  - 暴力法
    - 体素化，将空间划分为均匀网格
    - 对每个网格点，遍历所有三角形棉片，计算到该点的最短距离
    - 通过射线法或绕数法判断点是否在物体内部
    - 可以使用空间加速结构加速计算
  - 降维近似：对地形等简单几何体，将3D问题简化为2D高度场 + 垂直距离的计算
  - 扫描体素法：从几何体表面向外扩散，逐层更新距离值
- SDF的存储
  - 3D纹理
  - 稀疏存储，使用八叉树，仅存储非空区域的SDF
  - 使用一组基函数逼近，存储基函数参数
  - 使用神经网络近似
- Lumen
- Nanite
- 剔除算法
  - 视锥剔除
    - AABB 
    - 球体包围盒
  - 背面剔除：用于封闭模型的剔除，将背对摄像机的面剔除
  - 遮挡剔除`Occlusion Culling`：预先烘培深度信息，剔除被遮挡的物体，通常用于场景内有大型静态物体
  - 细节层次剔除`LOD Culling`：远处物体使用低模，近处物体使用高模
  - 入口裁剪`Portal Culling`：用于室内场景，通过门、窗等判断哪些房间可见
- 空间划分算法
  - BVH
  - KD-Tree
  - 空间网格哈希
- new分配空间的底层实现
  - 内存分配器
  - 构造器
  - placement new 在已经分配的内存上构造对象，而不会重新分配内存
- OpenGL的设置参数哪些对效率的影响最大
  - 过多的FBO切换
  - 过多的DrawCall
  - 过大的纹理和各向异性过滤
- PBR把diffuse和specular分开计算的意义
  - 符合物理原理，漫反射是经过多次反射、折射、散射形成的，镜面反射直接在表面反射形成
  - 便于适应不同材质，例如通过metallic等
  - 可以应用其他渲染方法，例如环境光遮蔽主要作用于漫反射，IBL主要作用于镜面反射

#### Unity 相关

- Unity 的几种管线,有什么区别
  - 内置渲染管线`Built-in Render Pipeline`：支持特性较少,适合对渲染质量要求不高以及需要大量自定义内容的开发者。
  - 通用渲染管线`Universal Render Pipeline`：适合需用兼顾性能和视觉效果的项目。
  - 高清渲染管线`High Definition Render Pipeline`：适合需要图形渲染和高质量画面的项目,支持更多高级功能,例如后处理效果、PBR,光线追踪等
- `CharacterController`和`Rigidbody`的区别
  前者用于角色控制,不与物理引擎直接交互,适合角色控制和简单的非物理互动。
- 碰撞检测的原理是
  Unity 使用物理引擎`NVIDIA PhysX`。碰撞检测的过程包括以下几个步骤：
  1. AABB 检测
  2. 精确碰撞检测：根据不同类型的碰撞体使用不同的检测算法
  3. 射线检测：常用于检测地面、物体的射线交互或玩家视线范围内的物体
  4. 连续碰撞检测：用于解决高速物体可能出现的碰撞体穿透问题,通过预测物体的轨迹并检测轨迹是否与其它物体相交来避免。
- 什么是链条关节`Hinge Joint`
  可以模拟两个物体间用一根链条连接在一起的情况,能保持两个物体在固定距离内部相互移动而不产生力,但在达到固定距离后就会产生拉力
- `RigidBody`有几种施加力的方式
- `UGUI Batching`合批
  - 使用相同材质和纹理的 UI 元素
  - 减少 Canvas 的频繁重绘
  - 使用图集减少纹理切换
  - 避免不必要的 Canvas 数量和`Pixel Perfect`模式
- `Image`和`RawImage`的区别
  - `Image`比`RawImage`更消耗性能
  - 前者只能使用`Sprite`属性的图片,后者皆可
  - 前者适合放需要旋转等操作的图片,后者适合放单独展示的图片
- 使用 Unity3D 实现 2D 游戏,有几种方式
  - 使用`UGUI`实现
  - 把摄像机的投影改为正交投影,不考虑 Z 轴
  - 使用 2D 模式,层级视图中只有一个正交摄像机,场景视图选择的是 2D 模式
  - 使用`2D TooKit`插件,提供高效的 2D 精灵和文本系统
- 如何在不同分辨率下保持 UI 的一致性
  保持 UI 的一致性需要考虑两个问题：
  1. 布局元素的位置,即屏幕分辨率变化的情况下,布局元素的位置可能固定不动,导致布局元素可能超出边界
  2. 布局元素的尺寸,即在屏幕分辨率变化的情况下,布局元素的大小尺寸会固定不变,导致布局元素之间出现重叠等功能。\
     解决这个问题使用到两个组件`Rect Transform`和`Canvas Scaler`
- `Canvas`的三种模式
  1. 屏幕空间-覆盖模式`Screen Space-Overlay`,默认模式,与摄像机无关只有横纵轴,UI 元素永远在游戏物体前。
  2. 屏幕空间-摄像机模式`Screen Space-Camera`,需要指定一个摄像机游戏物体,指定后 UGUI 就会自动出现在该摄像机的投射范围内,如果隐藏摄像机就不会渲染 UI。
  3. 世界空间模式`WorldSpace`,该模式下 UI 就相当于是场景内的普通游戏物体,可以在场景内任意移动 UI 元素的位置
- 游戏动画有哪几种,及其原理
  1. 关节动画
  2. 骨骼动画
  3. 单一网格模型动画
- `Avatar`的作用\
  Avatar 时 Unity 中的一个资源,用于描述角色的骨骼结构和骨骼映射`Skeleton Mapping`用于角色动画的驱动
- `AnimationType`
  1. `Humanoid`：支持标准化骨架,适合类人角色,支持 IK 等高级功能
  2. `Generic`：适合非类人角色,支持自定义股价
  3. `Legacy`：旧版动画系统,逐帧控制动画
- `Avator Mask`:用于实现动画的部分融合
- 协程的底层原理\
  协程通过迭代器来实现功能,通过`IEnumerator`来定义一个迭代方法。使用`yield`用于枚举状态,Unity 会在每一帧的生命周期中判断当前帧是否满足当前协程定义的条件,一旦满足就会执行当前`yield`条件的下一部分的代码
- 动态加载资源的方法
  1. `Instantiate`以实例化的方式动态生成一个物体
  2. 将资源打包成`Assetbundle`然后直接从中 load
  3. `Resource.Load()`把资源放在`Resource`命名的文件夹下,可以直接 load
  4. `AssetDatabase.loadasset()`只在编辑器内有效
- `AssetsBundle`：资源压缩包，可以包含所有游戏资源并在游戏运行时被加载；
  - AB 包自身存在相互依赖的关系
  - 压缩包使用 LZMA 和 LZ4 压缩算法，可以减少包大小，更快的进行网络传输
    - LZMA：使用复杂度引用技术规则，建立引用关系耗时，压缩率更高，只支持顺序读取
    - LZ4：使用块压缩方式，读取效率更高，压缩率较低，通过弱引用管理资源，减少CPU资源浪费
  - 把一些可以下载的内容放在里面，可以减少安装包的大小
  - 内容可以分为两类文件
    - `serialized file`资源序列化后统一写进单独文件
    - `resource file`单独保存的资源文件，方便快速加载
  - 具体开发流程
    - 创建 AB 包
    - 上传服务器
    - 下载 AB 包
    - 加载并更新游戏客户端
    - 卸载 AB 包
- `AssetsBundle`打包
- `AssetsBundle`加载
- 如何在不同工程间安全地迁移 asset 数据
  1. 将`Assets`目录和`Library`目录一起迁移
  2. 导出`Package`
  3. 使用 Unity 自带的`Assets Server`功能
- 各函数的发生顺序,哪些可能重复发生。\
  `Awake()` -> `OnEnable()` -> `Start()` -> `Update()` -> `FixedUpdate()` -> `LateUpdate()` -> `OnDestroy()` -> `OnApplicationQuit()`
  其中`OnEnable()`和`OnDisable()`会重复调用。
- 简述`prefab`的作用\
  相当于一个模板,对已有的素材、脚本、参数做一个默认的配置,便于以后修改；同时简化了导出的操作,便于团队交流。
- 在编辑场景时将`GameObject`设置为 Static 有什么作用
  当物体被静态物体挡住时会被剔除,减少渲染压力
- 什么是`Drawcall`
  每次引擎准备数据并通知 GPU 的过程称为一次 Drawcall(设置渲染状态：包括着色器、纹理、分配缓冲、绘制命令等)。
- BVH 和八叉树
- 网络同步：时刻保持多台机器的游戏表现完全一致 = 实时的多端数据同步+实时的多端表现
  - 状态同步
    - 同步每个客户端的状态，服务端通过接收用户的操作，计算结果后返回给各个客户端。
    - 缺陷：延迟过大、客户端性能浪费、服务端压力大、开发效率低、难以作出打击感和精确性、耗费流量多，难以做回放系统
    - 优点：安全性高、断线重连快、客户端性能优化优势比较明显
  - 帧同步
    - 客户端按照一定的帧速率上传操作指令，服务器将操作指令广播给所有客户端，服务器只转发操作，不做逻辑处理。适合少量玩家。
    - 缺陷：网络要求高、战斗逻辑都在客户端，会产生外挂(透视、自瞄等)，网络较差的客户端会影响其他玩家的游戏体验，不同机器的浮点数精度不同、随机数值计算不统一等
    - 优点：开发效率高、能实现更强的打击感、流量消耗稳定、
    - 乐观帧锁定
- 网络同步优化
  - 延迟主要包括采样延迟、渲染延迟、刷新延迟、显示延迟、网络延迟(处理延迟、传输延迟、排队延迟、传播延迟)。
  - 表现优化：状态同步中使用插值避免位置突变；预测和回滚，先执行指令，再和服务端的结果校验
  - 延迟补偿，使用记录的延迟时间前的位置计算攻击结果，但不适合 ACT 网游
  - 丢包对抗，对于延迟不敏感的游戏优先使用 TCP，对于数据量比较小的游戏可以采用冗余 UDP 数据包
  - 带宽优化：同步对象裁剪(不同步不需要的对象或区域)，分区(分房间)
- RHI 是什么`Render hardware interface`渲染硬件接口
- 如何设计一个游戏引擎 UI 框架,要考虑什么
- 什么是 IK(反向动力学)
- UI 自适应
- 抽象的本质是选择性忽略非关键细节来降低系统复杂度的认知工具,其运作机制遵循"关注点分离"原则,体现为：
  1. 信息隐藏：将实现细节封装在“黑箱”内
  2. 接口暴露：仅仅公开必要的交互方式
  3. 层次构建：建立不同抽象层级的协作关系
- Unity 合批规则、图集
  - 合批规则：需要 UI 元素使用相同的材质和着色器、需要在同一个 Canvas 中
  - 优化方法：减少 Canvas 数量、合并 UI 材质、按动静分组 UI、使用图集
- NavMesh 的寻路和底层实现
  - NavMesh 的生成
    - 体素化场景：将原几何数据通过体素化的方式生成 height field
    - 创建 Regions：将 heightfield 数据转换为天花板、地板等潜在的可跨越或通过的地形区域
    - 创建 Contours：从以上地形数据生成轮廓
    - 创建 Polygon：将轮廓转换为凸多边形
    - 创建 DetailMesh：从凸多边形转换到醉胡的三角形网格
  - 寻路通常基于 A\*算法；使用 RVO 算法或者势场法避障。
- 行为树和状态机的比较
  - 行为树相对于状态机的优势
    - 通用的行为可以封装成独立的子树，可复用性较强
    - 可以动态调整策略和子节点优先级
    - 更方比那调试和迭代
  - 状态机适合简单明确的流程
- Unity 渲染管线的主要区别

  | 特性         | Built-in     | URP                | HDRP                       |
  | ------------ | ------------ | ------------------ | -------------------------- |
  | 性能         | 依赖手动优化 | 优化良好           | 对性能要求高               |
  | 视觉效果     | 基本         | 提供 PBR、全局光照 | 支持多种高级图形技术       |
  | 灵活性       | 高度灵活     | 一般               | 灵活但是复杂               |
  | 光照与后处理 | 需要手动设置 | 内建多种效果       | 提供高级光照模型、体积光等 |
  | 渲染管线代码 |              | 限制性较强         |                            |

- LOD 算法
  - 生成：手动生成或者减面生成
  - 选择
    - 基于距离
    - 基于投影面积
    - 基于滞后：为了防止围绕在某个度量值的不必要的反复突跃现象，增加一个变化阈值
  - 切换：从一个细节层次转换搭配另一个细节层次
    - 离散几何 LOD
    - 混合 LOD
    - 透明 LOD
    - 连续 LOD
    - 几何形变 LOD
- `Unity DOTS` 面向数据的技术栈
  - Job System：一个多线程任务调度系统，可以将计算密集型任务并行化，基于任务窃取和任务队列技术
  - Burst Compiler：专门为任务系统设计的后端编译器，可以将C#代码优化为SIMD指令集和汇编
    - 支持自动向量化
    - 减少了C#的运行时开销，如GC
    - 支持跨平台优化
  - ECS


#### 计算机网络相关

- 自底向上五层：物理层、链路层、网络层、传输层、应用层
- TCP 和 UDP：在传输层上工作
  - 为端到端连接提供传输服务
  - TCP 可靠、UDP 不可靠
    - TCP具有可卡片的传输机制，包括带序列号的分段数据包、确认机制、超时重传、流量控制等。
    - UDP是无连接的、不维护序列号、不保证数据包到达和重传
  - 流量控制、差错控制
  - 三次握手、四次挥手
    - 三次握手：确认双方的接收、发送能力都是正常的，第三次握手可以放数据
    - 四次挥手:CSSC，确认双方数据发送完毕并确认关闭
- udp 丢包客户端怎么处理
  - 通过冗余发包减少丢包影响
  - 通过历史数据进行插值和预测
  - 进行丢包检测和请求重传
- 粘包问题
  - UDP 不会产生粘包问题
  - TCP 可以使用自定义的消息头或者固定的数据大小、以特殊字符结尾
